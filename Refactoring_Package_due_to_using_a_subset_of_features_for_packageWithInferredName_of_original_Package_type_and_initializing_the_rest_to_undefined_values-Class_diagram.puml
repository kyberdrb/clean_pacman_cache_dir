@startuml

'Proposed solutions to avoid assigning reference member attributes to temporary values in single-argument constructor:
' - Inheritance/Implementation of interface - a class with only pure virtual functions with commonfunctions
'   - overkill/not necessary - I don't use them in one container, neither I want to complicate my code with abstractions for simplicity and understandability
' - Splitting one 'PackageFile'
'   - to two classes
'   - then encapsulate the 'string' type 'filname' and 'absolutePath' member variables to custom defined classes 'Filename' and 'AbsolutePath' for expressivenes
'   - Accepted solution

class Package__the_original_one_before_refactoring {
    + Package(\
      \n    packageName : PackageName,\
      \n    locallyInstalledVersion : PackageVersion\
      \n    architecture : string\
      \n    isIgnored : bool)
    + Package(inferredPackageName : PackageName)
    + getName() : PackageName
    + getLocallyInstalledVersion() : PackageVersion
    + isPackageNameEmpty() : bool
    + hasStillSomethingInPackageName() : bool
    + getNextInferredPackageNameCandidate() : void
    + getStartingPositionForPackageVersion() : uint_fast8_t
    + getNumberOfInstallationPackageFilesForDifferentVersions()\
      \n    : uint_fast16_t
    + addPackageFileToDeletionCandidates(\
      \n    packageRelatedPackageFile : PackageFile) : void
    + movePackageFilesForDifferentVersionsToSeparateDir(\
      \n        pathToDirectoryForOtherVersionsOfPackageFiles : AbsolutePath)\
      \n    : void

    - PackageName name
    - PackageVersion locallyInstalledVersion
    - string architecture
    - bool isIgnored

    - installationPackageFilesForDifferentPackageVersions :\
      \n    vector<ExtendedInstallationPackageFile>>
}

'Analysis

'TODO make >>> abstract <<< from the 'class Package_refactored_' ?
class Package_refactored_ {
    + Package_refactored_(packageName : PackageName)
    + {abstract} ~Package_refactored_()

    + getName() : PackageName

    + operator<<(out : ostream, package : Package_refactored_) : ostream
    # {abstract} streamOutputOperator(out : ostream) : ostream

    + operator<(package : Package_refactored_, anotherPackage : Package_refactored_) : bool
    # {abstract} lessThanOperator(Package_refactored_ anotherPackage) : bool

    # name : PackageName
}

note left of Package_refactored_: function ""operator<""\nand virtual function ""lessThanOperator""\nare overloaded for\n""reference_wrapper"" and\n""unique_ptr""\nto ""Package_refactored_"" class

Package_refactored_ *-l-> "name\n1" PackageName

class PackageWithInferredName_refactored_ {
    + PackageWithInferredName_refactored_(extractedPackageNameAndVersionAsText : string)
    + isPackageNameEmpty() : bool
    + hasStillSomethingInPackageName() : bool
    + getNextInferredPackageNameCandidate() : void
    + extractPackageVersion() : PackageVersion
    # ostream streamOutputOperator(out : ostream)
    # lessThanOperator(anotherPackage : Package_refactored_) : bool

    - nameAndVersion : PackageNameAndVersion
    - getStartingPositionForPackageVersion() : uint_fast8_t
}

Package_refactored_ <|-u- PackageWithInferredName_refactored_
PackageWithInferredName_refactored_ .u.> "1" Package_refactored_
PackageWithInferredName_refactored_ .d.> "1" PackageVersion
PackageWithInferredName_refactored_ *-d-> "nameAndVersion\n1" PackageNameAndVersion

note bottom of PackageWithInferredName_refactored_: virtual function ""lessThanOperator""\nis overloaded for\n""reference_wrapper"" and\n""unique_ptr""\nto common abstract/virtual ""Package_refactored_"" base class

class LocallyInstalledPackage_refactored_ {
    + LocallyInstalledPackage_refactored_(\
      \n    PackageName packageName,\
      \n    PackageVersion locallyInstalledVersion,\
      \n    string architecture,\
      \n    bool isIgnored)
    + getNumberOfInstallationPackageFilesForDifferentVersions()\
      \n: uint_fast16_t
    + addPackageFileToDeletionCandidates(\
      \n    ExtendedInstallationPackageFile packageRelatedPackageFile)\
      \n: bool
    + movePackageFilesForDifferentVersionsToSeparateDir(\
      \n    absolutePathToDirectoryForOtherVersionsOfInstallationPackageFiles\
      \n        AbsolutePath)\
      \n: void

    # streamOutputOperator(ostream out) : ostream
    # lessThanOperator(anotherPackage : Package_refactored_) : bool

    - locallyInstalledVersion : PackageVersion
    - architecture : string
    - isIgnored : bool
    - installationPackageFilesForDifferentPackageVersions\
      \n    : vector<ExtendedInstallationPackageFile>
}

note bottom of LocallyInstalledPackage_refactored_: virtual function ""lessThanOperator""\nis overloaded for\n""reference_wrapper"" and\n""unique_ptr""\nto common abstract/virtual ""Package_refactored_"" base class

Package_refactored_ <|-u- LocallyInstalledPackage_refactored_
LocallyInstalledPackage_refactored_ .u.> "1" Package_refactored_
LocallyInstalledPackage_refactored_ *-d-> "locallyInstalledVersion\n1" PackageVersion
LocallyInstalledPackage_refactored_ *---> "installationPackageFilesForDifferentPackageVersions\n0..*" ExtendedInstallationPackageFile
LocallyInstalledPackage_refactored_ ...> "1" AbsolutePath
@enduml
